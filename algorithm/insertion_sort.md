# 插入排序
## 伪代码实现：
```
insertion_sort(A)
1 for j=2 to A.length
2     key=A[j]
3     i=j-1
4     while i>0 and A[i]>key
5         A[i+1]=A[i]
6         i=i-1
7     A[i+1]=key
```
## 证明：
思路：证明循环不变式在初始化、保持和终止三种状态下均为真。<br>
循环不变式定义：1-7行的for循环开始时，A[1..j-1]由原来位置的元素组成，但已按序排列。<br>
初始化：在第一次迭代之前，即j=2时。此时子数组A[1..j-1]为A[1]，循环不变式显然成立。<br>
保持：当j在(2, A.length)时，A[1..j-1]已经有序，此时需要将A[j]插入A[1..j]的某一位置中，使A[1..j]也有序，有以下两种情况：
- A[j]>=A[j-1]，此时未进入while循环，A没有操作，第7行由于i+1=j，也未操作。A[1..j]已按序排列。
- A[j]<A[j-1]，此时A[j]需要插入到A[1..j-1]里的某个位置，要这样做，首先需要找到一个位置k使得A[j]<A[k]，其次还要保证插入后，A[k,j]仍然有序，现在证明while循环具有这样的性质：<br>
进入while循环前记录下待插入的A[j]:=k。每次进入while循环，会将A[i]的位置移动到A[i+1]，而这时有A[i]=A[i+1]，此时A[1..j]已按序排列。显然，重复此过程直至i=0，A[1..j]仍然有序。QED<br>
现在考虑while循环的退出条件，有以下两种情况:<br>
(1) i=0时退出，由上一次循环i=1的操作结果可知，此时有key<A[1],A[1]=A[2]且A[1..j]整体有序，且A[1]为冗余的元素，此时将key插入A[1]的位置，则A[1..j]已按序排列且均由原来位置的元素组成；<br>
(2) A[i]<=key时退出，由上一次循环i=i+1的操作结果可知，此时有a[i]<=key<=A[i+1]=A[i+2]，且A[i+1]为冗余的元素，此时将key插入A[i+1]的位置，则循环不变式成立。<br>

终止：在循环终止时，j>A.length=n，因为每次循环j增加1，所以必有j=n+1，将j带入循环不变式的定义中，可得A[1..n]由原来位置的元素组成，但已按序排列。且注意到A[1..n]就是整个数组，因此算法正确。




